# DOM Events

Событие – это сигнал от браузера о том, что что-то произошло на странице. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

События мыши:

- `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
- `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.
- `mouseover` / `mouseout` – когда мышь наводится на / покидает элемент.
- `mousedown` / `mouseup` – когда нажали / отжали кнопку мыши на элементе.
- `mousemove` – при движении мыши.

События на элементах управления:
- `submit` – пользователь отправил форму `<form>`.
- `focus` – пользователь фокусируется на элементе, например нажимает на `<input>`.

Клавиатурные события:
- `keydown`/`keyup` – когда пользователь нажимает / отпускает клавишу.

События документа:
- `DOMContentLoaded` – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

CSS events:
- `transitionend` – когда CSS-анимация завершена.

## Обработчики событий
Событию можно назначить обработчик (handler), то есть функцию, которая сработает, как только событие произошло.

Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.

Есть несколько способов назначить событию обработчик:

### HTML Атрибут
Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.

Например, чтобы назначить обработчик события `click` на элементе `input`, можно использовать атрибут `onclick`, вот так:
```html
<input value="Нажми меня" onclick="alert('Клик!')" type="button">
```
> При клике мышкой на кнопке выполнится код, указанный в атрибуте onclick.

Внутри обработчика события доступна переменная `this`. Она ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.
```html
<button onclick="alert(this.innerHTML)">Нажми меня</button>
```
> При клике на кнопку button выводит своё содержимое, используя `this.innerHTML`.

### Использование свойства DOM-объекта
Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

К примеру, `elem.onclick`:
```html
<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>
```
Или, можно назначить существующую функцию:
```js
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```
> Эти способы, по сути, аналогичны предыдущему (через атрибут в HTML).

Так как у элемента DOM может быть только одно свойство с именем onclick, то назначить более одного обработчика так нельзя.

Убрать обработчик можно назначением `elem.onclick = null`.

**Внимание!**
Функция должна быть присвоена как **значение** `sayThanks`, а не результат вызова функции `sayThanks()`.
```js
// правильно
button.onclick = sayThanks;

// неправильно
button.onclick = sayThanks();
```
> Если добавить скобки, то sayThanks() – это уже вызов функции, результат которого (равный undefined, так как функция ничего не возвращает) будет присвоен onclick. Так что это не будет работать.

…А вот в разметке, в отличие от свойства, скобки нужны:
```html
<input type="button" id="button" onclick="sayThanks()">
```
Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создаёт функцию с телом из значения атрибута: `sayThanks()`.

Так что разметка генерирует такое свойство:
```js
button.onclick = function(event) {
  sayThanks(event); // содержимое атрибута
};
```
**Используйте именно функции, а не строки.**

Назначение обработчика строкой `elem.onclick = "alert(1)"` также сработает. Это сделано из соображений совместимости, но делать так не рекомендуется.

Не используйте `setAttribute` для обработчиков.
```js
// при нажатии на body будут ошибки,
// атрибуты всегда строки, и функция станет строкой
document.body.setAttribute('onclick', function() { alert(1) });
```

### addEventListener
Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.

Например, одна часть кода хочет при клике на кнопку делать её подсвеченной, а другая – выдавать сообщение.

Мы хотим назначить два обработчика для этого. Но новое DOM-свойство перезапишет предыдущее:
```js
input.onclick = function() { alert(1); }
// ...
input.onclick = function() { alert(2); } // заменит предыдущий обработчик
```

Альтеранативным сбособом для такого действия - это использование синтаксиса для добавления (а не присвоения) **нового** обработчика.

Синтаксис добавления обработчика:
```js
element.addEventListener(event, handler, [options]);
```
- `event`: Имя события, например "click".
- `handler`: Ссылка на функцию-обработчик.
- `options`: Дополнительный объект со свойствами:
    ```ts
    {
        once: boolean; // если true, тогда обработчик будет автоматически удалён после выполнения.
        capture: boolean; // фаза, на которой должен сработать обработчик
        passive: boolean; // если true, то указывает, что обработчик никогда не вызовет preventDefault(),
    }
    ```
Для ручного удаления уже добавленного обработчика следует использовать `removeEventListener`
```js
element.removeEventListener(event, handler, [options]);
```
Для удаления нужно передать именно ту функцию-обработчик которая была назначена, потому что фунцкия удаляется по ссылке!
```js
elem.addEventListener( "click" , () => alert('Спасибо!'));
// ....
elem.removeEventListener( "click", () => alert('Спасибо!')); // так не сработает
```
> Обработчик не будет удалён, т.к. в removeEventListener передана не та же функция, а другая, с одинаковым кодом, но это не важно.

Вот так правильно:
```js
function handler() {
  alert( 'Спасибо!' );
}

input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);
```
**Если функцию обработчик не сохранить где-либо (в переменной), мы не сможем её удалить**

Метод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:
```js
<input id="elem" type="button" value="Нажми меня"/>
<script>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>
```

#### Обработчики некоторых событий можно назначать только через `addEventListener`
Существуют события, которые нельзя назначить через DOM-свойство, но можно через `addEventListener`.

Например, таково событие `DOMContentLoaded`, которое срабатывает, когда завершена загрузка и построение DOM документа.
```js
document.onDOMContentLoaded = function() {
  alert("DOM построен"); // не будет работать
};
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM построен"); // а вот так сработает
});
```
Так что `addEventListener` более универсален. Хотя заметим, что таких событий меньшинство, это скорее исключение, чем правило.

P.S. Мы можем назначить обработчиком не только функцию, но и объект при помощи `addEventListener`. В этом случае, когда происходит событие, вызывается метод объекта `handleEvent`.
```html
<button id="elem">Нажми меня</button>

<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>
```
> Если `addEventListener` получает объект в качестве обработчика, он вызывает `object.handleEvent(event)`, когда происходит событие.

## Объект события
Любое событие генерирует объект, в котором описанны все нужные детали этого события.

Например при событии клика на элементе нам нужно понять какие координаты у указателя мыши, какая клавиша нажата и так далее.

Для этого нужно обратится к объекту события. Оно всегда приходит в функцию обработчика как первый параметр:
```html
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    console.log(event.type); // click
    console.log(event.currentTarget); // <input type=​"button" value=​"Нажми меня" id=​"elem">​ 
    console.log("Координаты: " + event.clientX + ":" + event.clientY); // Координаты: 85:18
  };
</script>
```
- `event.type` - Тип события, в данном случае "click".
- `event.currentTarget` - Элемент, на котором сработал обработчик. Значение – обычно такое же, как и у `this`.
- `event.clientX` / `event.clientY` - Координаты курсора в момент клика относительно окна, для событий мыши.

Разные события предоставляют разные данные о текущем событии.

# Итого
Есть три способа назначения обработчиков событий:

- Атрибут HTML: `onclick="..."`.
- DOM-свойство: `elem.onclick = function`.
- Специальные методы: `elem.addEventListener(event, handler[, phase])` для добавления, `removeEventListener` для удаления.

HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь

DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.

Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, например, `DOMContentLoaded`. Также `addEventListener` поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта `handleEvent`.

Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.